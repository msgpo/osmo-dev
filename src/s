#!/usr/bin/env bash
fastforwards=""

Git() {
  echo "git $@"
  git $@
  if [ "$?" != "0" ]; then
    echo "GIT RETURNED ERROR!"
    exit 1
  fi
}

Git_may_fail() {
  git $@
}

Git_branch() {
  echo "$(Git -C "$dir" status)" | grep 'On branch' | sed 's/On branch //'
}


gitk_start() {
  if [ -n "$DISPLAY" ]; then
    gitk --all &
    gitk_started="1"
  fi
}

status() {
  st="$(Git status)"
  mods="$(echo "$st" | grep 'modified:')"

  stline="$(echo "$st" | grep '\(behind\|ahead\|up-to-date\|diverged\)')"

  echo "$br"
  echo "$stline"
}

dance() {
  echo
  echo
  br="$(Git_branch)"

  echo "$dir"
  cd "$dir"

  status

  if [ -z "$mods" -a -n "$(echo "$stline" | grep up-to-date)" ]; then
    return 0
  fi

  gitk_start

  if [ -n "$mods" ]; then
    echo "Local mods"
    echo "$mods"
    echo
    echo "commit to new branch? (enter name, empty = no)"
    read wipbranch
    if [ -n "$wipbranch" ]; then
      Git checkout -b "$wipbranch"
      Git_may_fail commit -am wip
      #Git push --set-upstream origin "$wipbranch"
      Git checkout "$br"
    else
      echo "commit to this branch $br ?  (empty = no, 'ok' = yes)"
      read ok
      if [ "x$ok" = xok ]; then
        Git commit -am wip
        #Git push
      fi
    fi

    status

    if [ -n "$mods" ]; then
      return 0
    fi
  fi

  if [ -n "$(echo "$stline" | grep behind)" ]; then
    if [ -n "$(echo "$stline" | grep "and can be fast-forwarded")" ]; then
      echo "fast forwarding..."
      fastforwards="${fastforwards} $dir/$br:$(Git_may_fail rev-parse --short HEAD)"
      ok="ok"
    else
      echo "Behind. git merge?  (empty = no, 'ok' = yes)"
      read ok
    fi
    if [ "x$ok" = xok ]; then
      Git merge
    fi
  elif [ -n "$(echo "$stline" | grep ahead)" ]; then
    echo "Ahead. commit to new branch? (enter name, empty = no)"
    read wipbranch
    if [ -n "$wipbranch" ]; then
      Git checkout -b "$wipbranch"
      Git_may_fail commit -am wip
      #Git push --set-upstream origin "$wipbranch"
      Git checkout "$br"
    fi
    echo "$br: git reset --hard origin/$br ?  (empty = no, 'OK' IN CAPS = yes)"
    read ok
    if [ "x$ok" = xOK ]; then
      Git reset --hard "origin/$br"
    fi
    return 0
  elif [ -n "$(echo "$stline" | grep diverged)" ]; then
    echo "Diverged. git reset --hard origin/$br ?  (empty = no, 'OK' IN CAPS = yes)"
    read ok
    if [ "x$ok" = xOK ]; then
      wipbranch="neels/wip_$(date +%Y%m%d_%H%M)"
      Git checkout -b "$wipbranch"
      Git_may_fail commit -am wip
      Git checkout "$br"
      Git reset --hard "origin/$br"
    fi
  elif [ -z "$(echo "$stline" | grep up-to-date)" ]; then
    echo "Nothing to do."
    echo "$st"
  fi

}

kill_gitk() {
  if [ "$gitk_started" = "1" ]; then
    kill %1
    gitk_started="0"
  fi
}


basedir="$(pwd)"
gitk_started="0"
for gitdir in */.git ; do
  cd "$basedir"
  dir="$(dirname "$gitdir")"

  orig_branch="$(Git_branch)"

  kill_gitk
  dance
  cd "$basedir"

  if [ "$orig_branch" != master ]; then
	kill_gitk
	git -C "$dir" checkout master || continue
	dance
	cd "$basedir"
	pwd
	git -C "$dir" checkout "$orig_branch"
  fi

#  if [ "$dir" = "openbsc" ]; then
#    kill_gitk
#    Git checkout "sysmocom/iu"
#    dance
#  fi

  sleep .1

done

kill_gitk

echo
echo
./st

if [ -n "$fastforwards" ]; then
  echo
  echo "FAST-FORWARDED: $fastforwards"
fi

# vim: shiftwidth=2 expandtab
